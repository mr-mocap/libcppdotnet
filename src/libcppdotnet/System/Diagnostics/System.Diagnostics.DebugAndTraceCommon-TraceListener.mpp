export module System.Diagnostics.DebugAndTraceCommon:TraceListener;

import <algorithm>;

export import <concepts>;
export import <format>;
export import <memory>;
export import <string>;
export import <string_view>;

export import System.Collections.Specialized.StringDictionary;

export import System.Diagnostics.TraceOptions;
export import System.Diagnostics.TraceEventType;
export import :TraceEventCache;
export import :TraceFilter;

export namespace System::Diagnostics
{

class TraceListener
{
public:
    TraceListener();
    TraceListener(std::string_view name);
    virtual ~TraceListener() = default;

    std::string_view Name() const;
    void Name(const std::string &new_name) { _name = new_name; }
    void Name(std::string_view new_name) { _name = new_name; }

    TraceOptions TraceOutputOptions() const { return _options; }
    void         TraceOutputOptions(TraceOptions new_options) { _options = new_options; }

    virtual bool IsThreadSafe() const;

    bool NeedIndent() const;
    void NeedIndent(bool new_value) { _needIndent = new_value; }

    int  IndentLevel() const;
    void IndentLevel(int new_level);

    int  IndentSize() const;
    void IndentSize(int new_size);

    virtual void Close() = 0;
    virtual void Flush() = 0;

    virtual void Write(std::string_view message) = 0;
    virtual void Write(std::string_view message, std::string_view category) = 0;

    template <typename T, typename ...Args>
        requires (!std::convertible_to<T, std::string_view> || sizeof...(Args) > 0)
    void Write(std::format_string<T, Args...> &&fmt, T &&arg1, Args &&... args)
    {
        Write( std::string_view( std::vformat( fmt.get(), std::make_format_args( arg1, args... ) ) ) );
    }

    virtual void WriteLine(std::string_view message) = 0;
    virtual void WriteLine(std::string_view message, std::string_view category) = 0;

    template <typename T, typename ...Args>
        requires (!std::convertible_to<T, std::string_view> || sizeof...(Args) > 0)
    void WriteLine(std::format_string<T, Args...> &&fmt, T &&arg1, Args &&... args)
    {
        WriteLine( std::string_view( std::vformat( fmt.get(), std::make_format_args( arg1, args... ) ) ) );
    }

    virtual void Fail(std::string_view message) = 0;
    virtual void Fail(std::string_view message, std::string_view detail) = 0;

    template <typename T, typename ...Args>
        requires (!std::convertible_to<T, std::string_view> || sizeof...(Args) > 0)
    void Fail(std::format_string<T, Args...> &&fmt, T &&arg1, Args &&... args)
    {
        Fail( std::string_view( std::vformat( fmt.get(), std::make_format_args( arg1, args... ) ) ) );
    }

    virtual void WriteIndent() = 0;

    virtual void TraceData(System::Diagnostics::TraceEventCache &event_cache,
                                               std::string_view  source,
                            System::Diagnostics::TraceEventType  event_type,
                                                            int  id
                          );

    virtual void TraceData(System::Diagnostics::TraceEventCache &event_cache,
                                               std::string_view  source,
                            System::Diagnostics::TraceEventType  event_type,
                                                            int  id,
                                               std::string_view  message
                          );

    template <typename ...Args>
    void TraceData(System::Diagnostics::TraceEventCache  &event_cache,
                                       std::string_view   source,
                    System::Diagnostics::TraceEventType   event_type,
                                                    int   id,
                            std::format_string<Args...> &&fmt,
                                                   Args &&... args)
    {
        TraceData( event_cache,
                   source,
                   event_type,
                   id,
                   std::string_view( std::vformat( fmt.get(), std::make_wformat_args( args... ) ) )
                 );
    }

    const Collections::Specialized::StringDictionary &Attributes() const { return _attributes; }

    //?? GetSupportedAttributes() const;

    const TraceFilter *Filter() const { return _filter.get(); }
          TraceFilter *Filter()       { return _filter.get(); }
    
    void Filter(std::unique_ptr<TraceFilter> &&moved_ptr) { _filter = std::move(moved_ptr); }
protected:
    std::string  _name;
    int          _indentLevel = 0;
    int          _indentSize  = 0;
    TraceOptions _options     = TraceOptions::None;
    bool         _needIndent  = false;
    std::string  _indentString;
    Collections::Specialized::StringDictionary _attributes;
    std::unique_ptr<TraceFilter> _filter;

    void SetNeedIndent();
};

}

// Implementation
namespace System::Diagnostics
{

TraceListener::TraceListener()
{
}

TraceListener::TraceListener(std::string_view name)
    :
    _name{ name }
{
}

bool TraceListener::IsThreadSafe() const
{
    return false;
}

std::string_view TraceListener::Name() const
{
    return _name;
}

int TraceListener::IndentLevel() const
{
    return _indentLevel;
}

void TraceListener::IndentLevel(int new_level)
{
    _indentLevel = std::max(new_level, 0);
    _indentString.resize( _indentLevel * _indentSize, ' ' );
    SetNeedIndent();
}

int TraceListener::IndentSize() const
{
    return _indentSize;
}

void TraceListener::IndentSize(int new_size)
{
    _indentSize = std::max(new_size, 0);
    _indentString.resize( _indentLevel * _indentSize, ' ' );
    SetNeedIndent();
}

void TraceListener::SetNeedIndent()
{
    _needIndent = (_indentSize > 0) && (_indentLevel > 0);
}

void TraceListener::TraceData(System::Diagnostics::TraceEventCache &event_cache,
                                                  std::string_view  source,
                               System::Diagnostics::TraceEventType  event_type,
                                                               int  id
                          )
{
    // Treat as a partial function and really call the same method, but with an empty message
    TraceData( event_cache, source, event_type, id, std::string() );
}

void TraceListener::TraceData(System::Diagnostics::TraceEventCache &event_cache,
                                                  std::string_view  source,
                               System::Diagnostics::TraceEventType  event_type,
                                                               int  id,
                                                  std::string_view  message
                          )
{
    if ( !Filter() || (Filter() && Filter()->ShouldTrace( event_cache, source, event_type, id, message ) ) )
    {
        WriteLine("[Trace Header: Source=\"{}\" EventType=\"{}\" ID=\"{}\"]", source, event_type, id);
        WriteLine(message);
        WriteLine("[Trace Footer: Time=\"{}\" PID=\"{}\" TID=\"{}\" Timestamp=\"{}\"]",
                  event_cache.DateTime().ToString(),
                  event_cache.ProcessId(),
                  event_cache.ThreadId(),
                  event_cache.Timestamp()
                 );
    }
}

}