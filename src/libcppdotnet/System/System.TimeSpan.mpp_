export module System.TimeSpan;

import <cstdlib>;

export import <chrono>;
export import <compare>;
export import <format>;
export import <string>;

export import System.Exception;

export namespace System
{

class TimeSpan
{
public:
    TimeSpan() = default;
   ~TimeSpan() = default;
    explicit TimeSpan(int hours, int minutes, int seconds);
    explicit TimeSpan(int d, int h, int m, int s);
    explicit TimeSpan(int d, int h, int m, int s, int ms);
    explicit TimeSpan(long ticks);
    TimeSpan(std::chrono::system_clock::duration value);

    TimeSpan(const TimeSpan &other);
    TimeSpan(TimeSpan &&other);
    TimeSpan &operator =(const TimeSpan &other);
    TimeSpan &operator =(TimeSpan &&other);

    static TimeSpan FromTicks(long value);
    static TimeSpan FromMicroseconds(long value);
    static TimeSpan FromMilliseconds(long milli, long micro);
    static TimeSpan FromSeconds(long value);
    static TimeSpan FromMinutes(long value);
    static TimeSpan FromHours(int value);
    static TimeSpan FromDays(int value);

    static constexpr int  HoursPerDay() { return 24; }
    static constexpr long MinutesPerDay() { return 1'440; }
    static constexpr long SecondsPerDay() { return 86'400; }
    static constexpr long MillisecondsPerDay() { return 86'400'000; }
    static constexpr long MicrosecondsPerDay() { return 86'400'000'000; }

    static constexpr long MinutesPerHour() { return 60; }
    static constexpr long SecondsPerHour() { return 3'600; }
    static constexpr long MillisecondsPerHour() { return 3'600'000; }
    static constexpr long MicrosecondsPerHour() { return 3'600'000'000; }

    static constexpr long SecondsPerMinute() { return 60; }
    static constexpr long MillisecondsPerMinute() { return 60'000; }
    static constexpr long MicrosecondsPerMinute() { return 60'000'000; }

    static constexpr long MillisecondsPerSecond() { return 1000; }
    static constexpr long MicrosecondsPerSecond() { return 1'000'000; }
    static constexpr long NanosecondsPerSecond()  { return 1'000'000'000; }

    static constexpr long MicrosecondsPerMillisecond() { return 1'000; }

    static constexpr long NanosecondsPerTick() { return 100; }

    static constexpr long TicksPerDay() { return 864'000'000'000; }
    static constexpr long TicksPerHour() { return 36'000'000'000; }
    static constexpr long TicksPerMinute() { return 600'000'000; }
    static constexpr long TicksPerSecond() { return 10'000'000; }
    static constexpr long TicksPerMillisecond() { return 10'000; }
    static constexpr long TicksPerMicrosecond() { return 10; }

    static TimeSpan Zero();
    static TimeSpan MinValue();
    static TimeSpan MaxValue();

    long Ticks() const;

    //constexpr operator std::chrono::system_clock::duration() const { return _time_span; }
    operator std::chrono::system_clock::duration() const;

    int Days() const;
    int Hours() const;
    int Minutes() const;
    int Seconds() const;
    int Milliseconds() const;
    int Microseconds() const;
    int Nanoseconds() const;

    double TotalDays() const;
    double TotalHours() const;
    double TotalMinutes() const;
    double TotalSeconds() const;
    double TotalMilliseconds() const;
    double TotalMicroseconds() const;
    double TotalNanoseconds() const;

    TimeSpan &operator +=(std::chrono::system_clock::duration duration_to_add);
    TimeSpan &operator -=(std::chrono::system_clock::duration duration_to_subtract);

    template <class Representation>
    TimeSpan operator *=(const Representation &right);

    template <class Representation>
    TimeSpan operator /=(const Representation &right);

    TimeSpan Add(const TimeSpan &time_span) const;
    TimeSpan Subtract(const TimeSpan &time_span) const;
    TimeSpan Multiply(double scalar) const;
    TimeSpan Divide(double scalar) const;

    static constexpr int Compare(const TimeSpan &left, const TimeSpan &right)
    {
        std::strong_ordering result{ left <=> right };

        if ( result == std::strong_ordering::less )
            return -1;
        else if ( result == std::strong_ordering::equal )
            return 0;
        else
            return 1;
    }

    int CompareTo(const TimeSpan &other) const;

    static constexpr bool Equals(TimeSpan &left, TimeSpan &right)
    {
        return left == right;
    }

    TimeSpan Duration() const;
    TimeSpan Negate() const;

    std::string ToString() const;
protected:
    std::chrono::system_clock::duration _time_span{ std::chrono::system_clock::duration::zero() };


    friend constexpr bool operator ==(const TimeSpan &left, const TimeSpan &right)
    {
        return left._time_span == right._time_span;
    }

    friend constexpr std::strong_ordering operator <=>(const TimeSpan &left, const TimeSpan &right)
    {
        return left._time_span <=> right._time_span;
    }

    template <typename Rep, typename Period>
    friend TimeSpan operator +(const TimeSpan &left, const std::chrono::duration<Rep, Period> &right_as_duration)
    {
        return TimeSpan( left._time_span + right_as_duration );
    }

    friend TimeSpan operator +(const TimeSpan &left, const TimeSpan &right)
    {
        return TimeSpan( left._time_span + right._time_span );
    }

    template <typename Rep, typename Period>
    friend TimeSpan operator -(const TimeSpan &left, const std::chrono::duration<Rep, Period> &right_as_duration)
    {
        return TimeSpan( left._time_span - right_as_duration );
    }

    friend TimeSpan operator -(const TimeSpan &left, const TimeSpan &right)
    {
        return TimeSpan( left._time_span - right._time_span );
    }

    template <class Representation>
    friend TimeSpan operator *(const TimeSpan &left, const Representation &right)
    {
        return TimeSpan( left._time_span * static_cast<std::chrono::system_clock::rep>( right ) );
    }

    template <class Representation>
    friend TimeSpan operator *(const Representation &left, const TimeSpan &right)
    {
        return TimeSpan( static_cast<std::chrono::system_clock::rep>( left ) * right._time_span );
    }

    template <class Representation>
    friend TimeSpan operator /(const TimeSpan &left, const Representation &right)
    {
        return TimeSpan( left._time_span / static_cast<std::chrono::system_clock::rep>( right ) );
    }

    friend TimeSpan operator -(const TimeSpan &ts)
    {
        return TimeSpan( -ts._time_span );
    }

    friend TimeSpan operator +(const TimeSpan &ts)
    {
        return TimeSpan( +ts );
    }
};

}

export
template <>
struct std::formatter<System::TimeSpan>
{
    constexpr auto parse(std::format_parse_context &ctx)
    {
        return ctx.begin();
    }

    template <typename FormatContext>
    auto format(const System::TimeSpan &object, FormatContext &ctx) const
    {
        return std::format_to( ctx.out(), "{}", std::chrono::system_clock::duration(object) );
    }
};
